{"ast":null,"code":"'use client';\n\nimport * as React from 'react';\nimport { InteractionContext } from \"../context/InteractionProvider.js\";\nimport { useCartesianContext } from \"../context/CartesianProvider/index.js\";\nimport { isBandScale } from \"../internals/isBandScale.js\";\nimport { getSVGPoint } from \"../internals/getSVGPoint.js\";\nimport { useSvgRef } from \"./useSvgRef.js\";\nimport { useDrawingArea } from \"./useDrawingArea.js\";\nfunction getAsANumber(value) {\n  return value instanceof Date ? value.getTime() : value;\n}\nexport const useAxisEvents = disableAxisListener => {\n  const svgRef = useSvgRef();\n  const drawingArea = useDrawingArea();\n  const {\n    xAxis,\n    yAxis,\n    xAxisIds,\n    yAxisIds\n  } = useCartesianContext();\n  const {\n    dispatch\n  } = React.useContext(InteractionContext);\n  const usedXAxis = xAxisIds[0];\n  const usedYAxis = yAxisIds[0];\n\n  // Use a ref to avoid rerendering on every mousemove event.\n  const mousePosition = React.useRef({\n    isInChart: false,\n    x: -1,\n    y: -1\n  });\n  React.useEffect(() => {\n    const element = svgRef.current;\n    if (element === null || disableAxisListener) {\n      return () => {};\n    }\n    function getNewAxisState(axisConfig, mouseValue) {\n      const {\n        scale,\n        data: axisData,\n        reverse\n      } = axisConfig;\n      if (!isBandScale(scale)) {\n        const value = scale.invert(mouseValue);\n        if (axisData === undefined) {\n          return {\n            value,\n            index: -1\n          };\n        }\n        const valueAsNumber = getAsANumber(value);\n        const closestIndex = axisData?.findIndex((pointValue, index) => {\n          const v = getAsANumber(pointValue);\n          if (v > valueAsNumber) {\n            if (index === 0 || Math.abs(valueAsNumber - v) <= Math.abs(valueAsNumber - getAsANumber(axisData[index - 1]))) {\n              return true;\n            }\n          }\n          if (v <= valueAsNumber) {\n            if (index === axisData.length - 1 || Math.abs(getAsANumber(value) - v) < Math.abs(getAsANumber(value) - getAsANumber(axisData[index + 1]))) {\n              return true;\n            }\n          }\n          return false;\n        });\n        return {\n          value: closestIndex !== undefined && closestIndex >= 0 ? axisData[closestIndex] : value,\n          index: closestIndex\n        };\n      }\n      const dataIndex = scale.bandwidth() === 0 ? Math.floor((mouseValue - Math.min(...scale.range()) + scale.step() / 2) / scale.step()) : Math.floor((mouseValue - Math.min(...scale.range())) / scale.step());\n      if (dataIndex < 0 || dataIndex >= axisData.length) {\n        return null;\n      }\n      if (reverse) {\n        const reverseIndex = axisData.length - 1 - dataIndex;\n        return {\n          index: reverseIndex,\n          value: axisData[reverseIndex]\n        };\n      }\n      return {\n        index: dataIndex,\n        value: axisData[dataIndex]\n      };\n    }\n    const handleOut = () => {\n      mousePosition.current = {\n        isInChart: false,\n        x: -1,\n        y: -1\n      };\n      dispatch({\n        type: 'exitChart'\n      });\n    };\n    const handleMove = event => {\n      const target = 'targetTouches' in event ? event.targetTouches[0] : event;\n      const svgPoint = getSVGPoint(element, target);\n      mousePosition.current.x = svgPoint.x;\n      mousePosition.current.y = svgPoint.y;\n      if (!drawingArea.isPointInside(svgPoint, {\n        targetElement: event.target\n      })) {\n        if (mousePosition.current.isInChart) {\n          dispatch({\n            type: 'exitChart'\n          });\n          mousePosition.current.isInChart = false;\n        }\n        return;\n      }\n      mousePosition.current.isInChart = true;\n      const newStateX = getNewAxisState(xAxis[usedXAxis], svgPoint.x);\n      const newStateY = getNewAxisState(yAxis[usedYAxis], svgPoint.y);\n      dispatch({\n        type: 'updateAxis',\n        data: {\n          x: newStateX,\n          y: newStateY\n        }\n      });\n    };\n    const handleDown = event => {\n      const target = event.currentTarget;\n      if (!target) {\n        return;\n      }\n      if (target.hasPointerCapture(event.pointerId)) {\n        target.releasePointerCapture(event.pointerId);\n      }\n    };\n    element.addEventListener('pointerdown', handleDown);\n    element.addEventListener('pointermove', handleMove);\n    element.addEventListener('pointerout', handleOut);\n    element.addEventListener('pointercancel', handleOut);\n    element.addEventListener('pointerleave', handleOut);\n    return () => {\n      element.removeEventListener('pointerdown', handleDown);\n      element.removeEventListener('pointermove', handleMove);\n      element.removeEventListener('pointerout', handleOut);\n      element.removeEventListener('pointercancel', handleOut);\n      element.removeEventListener('pointerleave', handleOut);\n    };\n  }, [svgRef, dispatch, usedYAxis, yAxis, usedXAxis, xAxis, disableAxisListener, drawingArea]);\n};","map":{"version":3,"names":["React","InteractionContext","useCartesianContext","isBandScale","getSVGPoint","useSvgRef","useDrawingArea","getAsANumber","value","Date","getTime","useAxisEvents","disableAxisListener","svgRef","drawingArea","xAxis","yAxis","xAxisIds","yAxisIds","dispatch","useContext","usedXAxis","usedYAxis","mousePosition","useRef","isInChart","x","y","useEffect","element","current","getNewAxisState","axisConfig","mouseValue","scale","data","axisData","reverse","invert","undefined","index","valueAsNumber","closestIndex","findIndex","pointValue","v","Math","abs","length","dataIndex","bandwidth","floor","min","range","step","reverseIndex","handleOut","type","handleMove","event","target","targetTouches","svgPoint","isPointInside","targetElement","newStateX","newStateY","handleDown","currentTarget","hasPointerCapture","pointerId","releasePointerCapture","addEventListener","removeEventListener"],"sources":["D:/Vaishali/demo2/node_modules/@mui/x-charts/hooks/useAxisEvents.js"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { InteractionContext } from \"../context/InteractionProvider.js\";\nimport { useCartesianContext } from \"../context/CartesianProvider/index.js\";\nimport { isBandScale } from \"../internals/isBandScale.js\";\nimport { getSVGPoint } from \"../internals/getSVGPoint.js\";\nimport { useSvgRef } from \"./useSvgRef.js\";\nimport { useDrawingArea } from \"./useDrawingArea.js\";\nfunction getAsANumber(value) {\n  return value instanceof Date ? value.getTime() : value;\n}\nexport const useAxisEvents = disableAxisListener => {\n  const svgRef = useSvgRef();\n  const drawingArea = useDrawingArea();\n  const {\n    xAxis,\n    yAxis,\n    xAxisIds,\n    yAxisIds\n  } = useCartesianContext();\n  const {\n    dispatch\n  } = React.useContext(InteractionContext);\n  const usedXAxis = xAxisIds[0];\n  const usedYAxis = yAxisIds[0];\n\n  // Use a ref to avoid rerendering on every mousemove event.\n  const mousePosition = React.useRef({\n    isInChart: false,\n    x: -1,\n    y: -1\n  });\n  React.useEffect(() => {\n    const element = svgRef.current;\n    if (element === null || disableAxisListener) {\n      return () => {};\n    }\n    function getNewAxisState(axisConfig, mouseValue) {\n      const {\n        scale,\n        data: axisData,\n        reverse\n      } = axisConfig;\n      if (!isBandScale(scale)) {\n        const value = scale.invert(mouseValue);\n        if (axisData === undefined) {\n          return {\n            value,\n            index: -1\n          };\n        }\n        const valueAsNumber = getAsANumber(value);\n        const closestIndex = axisData?.findIndex((pointValue, index) => {\n          const v = getAsANumber(pointValue);\n          if (v > valueAsNumber) {\n            if (index === 0 || Math.abs(valueAsNumber - v) <= Math.abs(valueAsNumber - getAsANumber(axisData[index - 1]))) {\n              return true;\n            }\n          }\n          if (v <= valueAsNumber) {\n            if (index === axisData.length - 1 || Math.abs(getAsANumber(value) - v) < Math.abs(getAsANumber(value) - getAsANumber(axisData[index + 1]))) {\n              return true;\n            }\n          }\n          return false;\n        });\n        return {\n          value: closestIndex !== undefined && closestIndex >= 0 ? axisData[closestIndex] : value,\n          index: closestIndex\n        };\n      }\n      const dataIndex = scale.bandwidth() === 0 ? Math.floor((mouseValue - Math.min(...scale.range()) + scale.step() / 2) / scale.step()) : Math.floor((mouseValue - Math.min(...scale.range())) / scale.step());\n      if (dataIndex < 0 || dataIndex >= axisData.length) {\n        return null;\n      }\n      if (reverse) {\n        const reverseIndex = axisData.length - 1 - dataIndex;\n        return {\n          index: reverseIndex,\n          value: axisData[reverseIndex]\n        };\n      }\n      return {\n        index: dataIndex,\n        value: axisData[dataIndex]\n      };\n    }\n    const handleOut = () => {\n      mousePosition.current = {\n        isInChart: false,\n        x: -1,\n        y: -1\n      };\n      dispatch({\n        type: 'exitChart'\n      });\n    };\n    const handleMove = event => {\n      const target = 'targetTouches' in event ? event.targetTouches[0] : event;\n      const svgPoint = getSVGPoint(element, target);\n      mousePosition.current.x = svgPoint.x;\n      mousePosition.current.y = svgPoint.y;\n      if (!drawingArea.isPointInside(svgPoint, {\n        targetElement: event.target\n      })) {\n        if (mousePosition.current.isInChart) {\n          dispatch({\n            type: 'exitChart'\n          });\n          mousePosition.current.isInChart = false;\n        }\n        return;\n      }\n      mousePosition.current.isInChart = true;\n      const newStateX = getNewAxisState(xAxis[usedXAxis], svgPoint.x);\n      const newStateY = getNewAxisState(yAxis[usedYAxis], svgPoint.y);\n      dispatch({\n        type: 'updateAxis',\n        data: {\n          x: newStateX,\n          y: newStateY\n        }\n      });\n    };\n    const handleDown = event => {\n      const target = event.currentTarget;\n      if (!target) {\n        return;\n      }\n      if (target.hasPointerCapture(event.pointerId)) {\n        target.releasePointerCapture(event.pointerId);\n      }\n    };\n    element.addEventListener('pointerdown', handleDown);\n    element.addEventListener('pointermove', handleMove);\n    element.addEventListener('pointerout', handleOut);\n    element.addEventListener('pointercancel', handleOut);\n    element.addEventListener('pointerleave', handleOut);\n    return () => {\n      element.removeEventListener('pointerdown', handleDown);\n      element.removeEventListener('pointermove', handleMove);\n      element.removeEventListener('pointerout', handleOut);\n      element.removeEventListener('pointercancel', handleOut);\n      element.removeEventListener('pointerleave', handleOut);\n    };\n  }, [svgRef, dispatch, usedYAxis, yAxis, usedXAxis, xAxis, disableAxisListener, drawingArea]);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}