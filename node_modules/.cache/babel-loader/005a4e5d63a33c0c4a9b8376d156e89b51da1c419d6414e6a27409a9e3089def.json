{"ast":null,"code":"'use client';\n\nimport * as React from 'react';\nimport { InteractionContext } from \"../context/InteractionProvider.js\";\nimport { useSeries } from \"../hooks/useSeries.js\";\nimport { useCartesianContext } from \"../context/CartesianProvider/index.js\";\nimport { ZAxisContext } from \"../context/ZAxisContextProvider.js\";\nimport { useColorProcessor } from \"../context/PluginProvider/useColorProcessor.js\";\nimport { getLabel } from \"../internals/getLabel.js\";\nimport { isCartesianSeriesType } from \"../internals/isCartesian.js\";\nimport { utcFormatter } from \"./utils.js\";\nexport function useAxisTooltip() {\n  const {\n    axis\n  } = React.useContext(InteractionContext);\n  const series = useSeries();\n  const {\n    xAxis,\n    yAxis,\n    xAxisIds,\n    yAxisIds\n  } = useCartesianContext();\n  const {\n    zAxis,\n    zAxisIds\n  } = React.useContext(ZAxisContext);\n  const colorProcessors = useColorProcessor();\n\n  // By default use the x-axis\n  const isXaxis = axis.x !== null && axis.x.index !== -1;\n  const axisData = isXaxis ? axis.x && axis.x : axis.y && axis.y;\n  if (axisData === null) {\n    return null;\n  }\n  const {\n    index: dataIndex,\n    value: axisValue\n  } = axisData;\n  const USED_AXIS_ID = isXaxis ? xAxisIds[0] : yAxisIds[0];\n  const usedAxis = isXaxis ? xAxis[USED_AXIS_ID] : yAxis[USED_AXIS_ID];\n  const relevantSeries = Object.keys(series).filter(isCartesianSeriesType).flatMap(seriesType => {\n    const seriesOfType = series[seriesType];\n    if (!seriesOfType) {\n      return [];\n    }\n    return seriesOfType.seriesOrder.map(seriesId => {\n      const seriesToAdd = seriesOfType.series[seriesId];\n      const providedXAxisId = seriesToAdd.xAxisId ?? seriesToAdd.xAxisKey;\n      const providedYAxisId = seriesToAdd.yAxisId ?? seriesToAdd.yAxisKey;\n      const axisKey = isXaxis ? providedXAxisId : providedYAxisId;\n\n      // Test if the series uses the default axis\n      if (axisKey === undefined || axisKey === USED_AXIS_ID) {\n        const xAxisId = providedXAxisId ?? xAxisIds[0];\n        const yAxisId = providedYAxisId ?? yAxisIds[0];\n        const zAxisId = seriesToAdd.zAxisId ?? seriesToAdd.zAxisKey ?? zAxisIds[0];\n        const color = colorProcessors[seriesType]?.(seriesToAdd, xAxis[xAxisId], yAxis[yAxisId], zAxisId && zAxis[zAxisId])(dataIndex) ?? '';\n        const value = seriesToAdd.data[dataIndex] ?? null;\n        const formattedValue = seriesToAdd.valueFormatter(value, {\n          dataIndex\n        });\n        const formattedLabel = getLabel(seriesToAdd.label, 'tooltip') ?? null;\n        return {\n          seriesId,\n          color,\n          value,\n          formattedValue,\n          formattedLabel\n        };\n      }\n      return undefined;\n    });\n  }).filter(item => item != null);\n  const axisFormatter = usedAxis.valueFormatter ?? (v => usedAxis.scaleType === 'utc' ? utcFormatter(v) : v.toLocaleString());\n  const axisFormattedValue = axisFormatter(axisValue, {\n    location: 'tooltip'\n  });\n  return {\n    identifier: axis,\n    seriesItems: relevantSeries,\n    axisValue,\n    axisFormattedValue\n  };\n}","map":{"version":3,"names":["React","InteractionContext","useSeries","useCartesianContext","ZAxisContext","useColorProcessor","getLabel","isCartesianSeriesType","utcFormatter","useAxisTooltip","axis","useContext","series","xAxis","yAxis","xAxisIds","yAxisIds","zAxis","zAxisIds","colorProcessors","isXaxis","x","index","axisData","y","dataIndex","value","axisValue","USED_AXIS_ID","usedAxis","relevantSeries","Object","keys","filter","flatMap","seriesType","seriesOfType","seriesOrder","map","seriesId","seriesToAdd","providedXAxisId","xAxisId","xAxisKey","providedYAxisId","yAxisId","yAxisKey","axisKey","undefined","zAxisId","zAxisKey","color","data","formattedValue","valueFormatter","formattedLabel","label","item","axisFormatter","v","scaleType","toLocaleString","axisFormattedValue","location","identifier","seriesItems"],"sources":["D:/Vaishali/demo2/node_modules/@mui/x-charts/ChartsTooltip/useAxisTooltip.js"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { InteractionContext } from \"../context/InteractionProvider.js\";\nimport { useSeries } from \"../hooks/useSeries.js\";\nimport { useCartesianContext } from \"../context/CartesianProvider/index.js\";\nimport { ZAxisContext } from \"../context/ZAxisContextProvider.js\";\nimport { useColorProcessor } from \"../context/PluginProvider/useColorProcessor.js\";\nimport { getLabel } from \"../internals/getLabel.js\";\nimport { isCartesianSeriesType } from \"../internals/isCartesian.js\";\nimport { utcFormatter } from \"./utils.js\";\nexport function useAxisTooltip() {\n  const {\n    axis\n  } = React.useContext(InteractionContext);\n  const series = useSeries();\n  const {\n    xAxis,\n    yAxis,\n    xAxisIds,\n    yAxisIds\n  } = useCartesianContext();\n  const {\n    zAxis,\n    zAxisIds\n  } = React.useContext(ZAxisContext);\n  const colorProcessors = useColorProcessor();\n\n  // By default use the x-axis\n  const isXaxis = axis.x !== null && axis.x.index !== -1;\n  const axisData = isXaxis ? axis.x && axis.x : axis.y && axis.y;\n  if (axisData === null) {\n    return null;\n  }\n  const {\n    index: dataIndex,\n    value: axisValue\n  } = axisData;\n  const USED_AXIS_ID = isXaxis ? xAxisIds[0] : yAxisIds[0];\n  const usedAxis = isXaxis ? xAxis[USED_AXIS_ID] : yAxis[USED_AXIS_ID];\n  const relevantSeries = Object.keys(series).filter(isCartesianSeriesType).flatMap(seriesType => {\n    const seriesOfType = series[seriesType];\n    if (!seriesOfType) {\n      return [];\n    }\n    return seriesOfType.seriesOrder.map(seriesId => {\n      const seriesToAdd = seriesOfType.series[seriesId];\n      const providedXAxisId = seriesToAdd.xAxisId ?? seriesToAdd.xAxisKey;\n      const providedYAxisId = seriesToAdd.yAxisId ?? seriesToAdd.yAxisKey;\n      const axisKey = isXaxis ? providedXAxisId : providedYAxisId;\n\n      // Test if the series uses the default axis\n      if (axisKey === undefined || axisKey === USED_AXIS_ID) {\n        const xAxisId = providedXAxisId ?? xAxisIds[0];\n        const yAxisId = providedYAxisId ?? yAxisIds[0];\n        const zAxisId = seriesToAdd.zAxisId ?? seriesToAdd.zAxisKey ?? zAxisIds[0];\n        const color = colorProcessors[seriesType]?.(seriesToAdd, xAxis[xAxisId], yAxis[yAxisId], zAxisId && zAxis[zAxisId])(dataIndex) ?? '';\n        const value = seriesToAdd.data[dataIndex] ?? null;\n        const formattedValue = seriesToAdd.valueFormatter(value, {\n          dataIndex\n        });\n        const formattedLabel = getLabel(seriesToAdd.label, 'tooltip') ?? null;\n        return {\n          seriesId,\n          color,\n          value,\n          formattedValue,\n          formattedLabel\n        };\n      }\n      return undefined;\n    });\n  }).filter(item => item != null);\n  const axisFormatter = usedAxis.valueFormatter ?? (v => usedAxis.scaleType === 'utc' ? utcFormatter(v) : v.toLocaleString());\n  const axisFormattedValue = axisFormatter(axisValue, {\n    location: 'tooltip'\n  });\n  return {\n    identifier: axis,\n    seriesItems: relevantSeries,\n    axisValue,\n    axisFormattedValue\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}